<style>
    table, th, td {
        border: 1px solid;
        border-collapse: collapse;
    }
    td:hover{
        color: blue;
        text-decoration: underline;
    }
    table {
        table-layout: auto;
        width: 50%;
    }
</style>

<link rel="stylesheet" type="text/css" href="/css/temp.css">

<p>All of your incoming encrypted messages are below, please select a message to decrypt it:</p>

<!-- Testing purposes -->
% user  = Gordon
% m_list  = ["dasadasdaddsadas","is","the","mesasdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaasage","list"]
% if not m_list:
<p>You have no messages!</p>
% else:
<table>
    <thead>
      <tr>
        <th>Message</th>
      </tr>
    </thead>
    <tbody>
        % for n in range(len(m_list)):
        <tr>
            <td id= "message_{{n}}" onclick="decrypt({{n}})" > {{m_list[n]}} </td>
        </tr>
        % end
    </tbody>
  </table>
% end


<script>
    // Storing the messages to decrypt
    const messages =  {{!m_list}};
    function decrypt(n){  
        const to_decrypt = messages[n];
        const m_id = "message_".concat(n.toString());
        // alert(m_id)
        // alert(document.getElementById(m_id));
        // alert(messages[n]);

        };
    
    // Importing the private key of a user from cookies
    function importPrivateKey(jwk) {
        return window.crypto.subtle.importKey("jwk", jwk, {
            name: "ECDSA", 
            namedCurve: "P-384"
        },
        true,
        ["decrypt"]
        );
    }


    function getWebKey(username) {
        // let name = username + "=";
        let decoded_cookies = decodeURIComponent(document.cookie);
        let cookie_array = decoded_cookies.split(';');
        for (cookie in cookie_array){
            crumb = cookie.split('=');
            // Check for username matching
            if (crumb[0]==username) {
                return crumb[1]
            }
        }
    }
    
</script>



<script>
    importPrivateKeyAndDecrypt();

    // Retrieve cookies
    
    const j_web_key = json.parse()
    const privateKey = importPrivateKey()
    
    async function importPrivateKeyAndDecrypt() {
    
        // A ciphertext produced with the first code
        const ciphertextB64 = "q/g0YQ+CbFwCb9QxAeKk/X8vjUUKpBGCVe6OvFoBlTfRF24BQlWpLFhxVQv+Gn29CzAXfSJjU+C8taYXQ4wofyOaRx0etkATDbmIV1gVdxNnqVKTx2RSj1L3uACZ3aWYIGRjtaBMBNAW81mPEjxEWCvRW3uI/rOn3LAc4N05CkofOnsIpaafgcEjhZoTxp1Dpkm328bwRJ3g1Dn+vQk6JBiAXSiF7GHvMvnD6q+CQiO1dcv0lrrXlibE8/P2LHWpqQ9g5xWWUHl70q2WB+IxLgX9OkqX8XQ1GHjP5EaQFfo1HerBpa+Uf5DaienI/XT4n64DWM1S7t0dbhFDskc9HQ==";
            
        try {
            const priv = await importPrivateKey(privateKey);
            const decrypted = await decryptRSA(priv, str2ab(window.atob(ciphertextB64)));
            console.log(decrypted);
        } catch(error) {
            console.log(error);
        }
    }
    
    async function decryptRSA(key, ciphertext) {
        let decrypted = await window.crypto.subtle.decrypt(
            {
                name: "RSA-OAEP"
            },
            key,
            ciphertext
        );
        return new TextDecoder().decode(decrypted);
    }
    
    //
    // Helper
    //
        
    // https://stackoverflow.com/a/11058858
    function str2ab(str) {
        const buf = new ArrayBuffer(str.length);
        const bufView = new Uint8Array(buf);
        for (let i = 0, strLen = str.length; i < strLen; i++) {
            bufView[i] = str.charCodeAt(i);
        }
        return buf;
    }
        
    function ab2str(buf) {
        return String.fromCharCode.apply(null, new Uint8Array(buf));
    }
</script>